#!/usr/bin/env python
#
# Copyright The IETF Trust 2007, 2008, All Rights Reserved
#
# Import users from all different IETF authentication sources into
# django.  Map user names to people via the ietf.ietfauth.models.UserMap
# model.  Use the htpasswd file to get passwords, ignoring any password
# stored in the database.
#
# If the user already exists, just update their group memberships
# and/or privileges.  This script can be run multiple times with no
# adverse effect.
#
# Note that there are a couple of people who have multiple accounts.
# This scheme will give them one single account, with all of the
# privilges of the original account.
#
# Data sources:
# - IESGLogin
# - LegacyWgPassword
# - Liaison tool ('Users')
# - Then look for email address
#
# The LegacyWgPassword table contains a plaintext password, which is
# both unconscionable and very useful, as it lets us upgrade their
# password to full htdigest style.
#
#
from ietf.idtracker.models import PersonOrOrgInfo, IESGLogin, EmailAddress
from ietf.ietfauth.models import LegacyWgPassword, LegacyLiaisonUser
from ietf.ietfauth.auth import set_password
from ietf.utils import users
from django.core.validators import email_re
from django.contrib.auth.models import Group
import sys

# Group mappings for IESGLogin entries
level2group = {
	0:	'Secretariat',
	1:	'IESG',
	2:	'ex-IESG',
}
if len(sys.argv) != 2:
    print "usage: import-users htpasswd"
    sys.exit(1)
    

f = open(sys.argv[1], 'r')
line = f.readline()
while line != '':
    (user, pw) = line.rstrip("\n").split(":")
    person = None
    wg = None
    # Some login names are a different E-Mail
    # address than the one stored in email_addresses.
    # If the login name looks like an email address
    # then use it.
    if email_re.search(user):
	email = user
    else:
	email = None
    try:
	iesg = IESGLogin.objects.get(login_name=user)
	try:
	    person = iesg.person
	except PersonOrOrgInfo.DoesNotExist:
	    iesg = None
    except IESGLogin.DoesNotExist:
	iesg = None
    if person is None:
	try:
	    wg = LegacyWgPassword.objects.get(login_name=user)
	    person = wg.person
	except LegacyWgPassword.DoesNotExist:
	    pass
	except AssertionError:
	    print "%s has multiple WGPassword rows, so couldn't pick" % user
    if person is None:
	try:
	    liaison = LegacyLiaisonUser.objects.get(login_name=user)
	    person = liaison.person
	except LegacyLiaisonUser.DoesNotExist:
	    pass
    if person is None and email:
	try:
	    person = PersonOrOrgInfo.objects.distinct().get(emailaddress__address__iexact=user)
	except PersonOrOrgInfo.DoesNotExist:
	    pass
	except AssertionError:
	    print "%s has multiple PersonOrOrgInfo entries, so couldn't pick" % email
    if person is not None:
	try:
	    u = users.create_user(user, email, person, cryptpw=pw)
	except users.UserAlreadyExists, (msg, u):
	    print "Already in system as %s when adding %s (%s)" % ( u.username, user, email )
	    if not email_re.search( user ):
		# If the existing username looks like it's one we made up
		# (first_last), then change it to the one in the digest file.
		if "_" in u.username:
		    print "Changing username from %s to %s" % ( u.username, user )
		    u.username = user
		    u.save()
	if iesg:
	    try:
		group, created = Group.objects.get_or_create(name = level2group[iesg.user_level])
	    except KeyError:
		group = None
	    if group:
		print "Adding %s to %s (user_level %d)" % (u.username, group.name, iesg.user_level)
		u.groups.add(group)
	if wg and wg.password:
	    # Use the plaintext password
	    set_password( u, wg.password )
    else:
	print "Could not map %s to person" % ( user )
    line = f.readline()
